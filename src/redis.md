## 1. 为什么要使用redis?
------
我们在研发项目的过程中，需要提升我们的项目响应效率，通常我们都会选用redis作为我们的缓存系统；
现在越来越多的分布式系统中需要实现分布式的锁结构，redis可以轻松的帮我们实现分布式锁；
redis具有丰富的数据结构，我们可以轻松的帮我们完成项目中的各类场景；

## 2. redis有哪些数据结构
1. String
2. Hash
3. Set
4. List
5. ZSet

## 3.为什么单线程的redis效率很高
1. 纯内存操作
2. IO多路复用
3. 单线程减少线程切换开销

## 4. 数据过多超过内存上限了，怎么办?(内存淘汰机制)
> LRU(Last Recently Used)
1. noeviction (当新插入时会报错，不删数据)
2. allkeys-lru (移除最少使用的key)
3. allkeys-random (随机)
4. volatile-lru (设置了过期时间的key中，移除最少使用的)
5. volatile-random (设置了过期时间key里面的随机)
6. volatile-ttl (设置了过期时间key里面，有更早过期时间的key优先删除)

## 5. redis 如何保证高并发&高可用?
redis使用了主从架构(一主多从)，提高了响应效率，保证了主节点挂掉之后，切换到从节点。从节点上拥有了主节点的数据备份；Sentinel监控并实现主从切换。

## 6. redis主从架构的数据同步机制?
> redis默认先实现增量同步，失败后再尝试全量同步
1. 全量同步主节点生成RDB(快照文件)发送给从节点，从节点加载RDB实现数据初同步；
2. 增量同步是主节点执行操作后，将写操作发送给从节点，从节点执行收到的命令

## 7. redis的持久化机制及其特点
> redis可同时开启RDB&AOF
1. RDB(快照)
    - 行为：每间隔n秒，生成一份快照信息
    - 优点：可快速实现全量同步，重加载和同步效率高
    - 缺点：每次生成文件的效率低，以及由于控制力度小会有部分数据丢失
2. AOF(Append of file)
    - 行为：每个写操作，都追加到文件尾部
    - 优点：生成的效率高，可自动校验，并修复损坏文件(修改最后一条日志)
    - 缺点：重加载和同步的效率低

## 8. sentinel如何保证自身的高可用?
sentinel集群，奇数个sentinel，选举出leader，follower都是通过心跳来判断leader的存在。

## 9. 多节点的集群用hash算法存在什么问题? 如何解决
- 当某个节点挂掉的时候，会出现hash无法定位数据真实所在的节点，导致无法命中。
- 可以用一致性Hash解决。一致性Hash是采用一个2^32个节点抽象成的一个Hash环，数据分布的节点的Hash算法是对Hash环进行取余，因此当Hash环上任意一个节点数据丢失，都不会导致其他的节点数据的命中

## 10. 一致性Hash存在什么问题?怎么解决
- 当节点上数据比较少的时候，可能会出现数据分布不均匀。
- 可以使用虚拟节点方式解决。一个节点虚拟出多个节点，并把数据分布到这些节点中去，这样就实现了数据的再平均。

## 11. redis cluster怎么实现?
> gossip协议使用ping，pong，fail，meet进行通讯等
- 介绍：redis cluster是通过多个主从架构的节点，通过gossip的协议通讯，每个节点上都包含了多个slot，数据就是分布在slot中的，形成的一个高可用的集群。
- 特点：redis集群负责数据分布，不需要依赖从client or proxy做数据定位。

## 12. redis cluster的增加or删除节点为什么可以对其他节点没有影响？
其实redis cluster也采用的是一致性Hash算法，只不过将hash环上的节点替换成了slot。redis删除节点，cluster会将该节点上的slot都转移到其他节点上去。增加节点也是把slot分配一部分到新节点。

## 13. redis cluster中有节点挂掉之后怎么处理?
某个节点挂了之后，会被cluster发现并做主从切换

## 14. 缓存如何解决热点key问题?
项目中可预知的热点数据，预先加载到缓存中

## 15. 缓存击穿之后怎么处理?
设置lock，只有一个请求可以真正访问到数据库，拿到数据后放到缓存中，其他的请求阻塞直到可以从缓存中拿到数据(当然可以设置timeout时间)

## 16.缓存雪崩怎么处理?
1. 设置数据过期时间，加随机值防止同一时间过期
2. 对于热点数据记性持续预加载
3. 双缓存策略，主缓存和次缓存
```java
if (tryLock()) {
    cache1.put();
    cache2.put();
} else {
    cache2.get();
}
```